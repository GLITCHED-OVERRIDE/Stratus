<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stratus Launcher</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
body { margin:0; font-family: Arial; background:#000; color:#fff; padding:70px 20px 20px 20px; }
.item { background:#111; padding:15px; margin:15px auto; width:85%; cursor:pointer; border:1px solid #fff; border-radius:10px; text-align:center; }
</style>
</head>
<body>

<h1>Stratus Launcher</h1>
<div id="apps"></div>

<script>
const JSON_URL = "https://raw.githubusercontent.com/GLITCHED-OVERRIDE/Stratus/refs/heads/main/Apps.json";

async function loadApps() {
    const res = await fetch(JSON_URL);
    const apps = await res.json();
    const container = document.getElementById("apps");

    apps.forEach(app=>{
        const div = document.createElement("div");
        div.className = "item";
        div.textContent = app.name;
        div.addEventListener("click",()=>launchApp(app));
        container.appendChild(div);
    });
}

loadApps();

async function launchApp(app){
    // Fetch ZIP
    const res = await fetch(app.url);
    const blob = await res.blob();
    const zip = await JSZip.loadAsync(blob);

    // Map filenames to blob URLs
    const fileMap = {};
    for(const filename of Object.keys(zip.files)){
        const fBlob = await zip.files[filename].async("blob");
        fileMap["/"+filename] = fBlob; // prepend / to mimic root
    }

    // Register Service Worker for virtual file system
    if('serviceWorker' in navigator){
        const swBlob = new Blob([`
        const files = ${JSON.stringify(Object.keys(fileMap))};
        const fileBlobs = {};
        self.addEventListener('install', e=>{
            e.waitUntil((async ()=>{
                for(const f of files){
                    const resp = await fetch(f); // placeholder
                    fileBlobs[f] = f; // will override in main
                }
            })());
            self.skipWaiting();
        });

        self.addEventListener('fetch', e=>{
            const url = new URL(e.request.url);
            const pathname = url.pathname;
            if(fileBlobs[pathname]){
                e.respondWith(fetch(fileBlobs[pathname]));
            }
        });
        `], {type:'application/javascript'});
        const swUrl = URL.createObjectURL(swBlob);
        try{ await navigator.serviceWorker.register(swUrl); }catch(e){console.log(e);}
    }

    // Open new window
    const win = window.open("about:blank");
    win.document.write("<!DOCTYPE html><html><head><title>"+app.name+"</title></head><body style='margin:0;background:#000;color:#fff;'><iframe id='appFrame' style='width:100%;height:100vh;border:none'></iframe></body></html>");

    // Create iframe with virtual file protocol
    const iframe = win.document.getElementById("appFrame");

    // Build a Blob URL for index.html
    const indexFileName = Object.keys(fileMap).find(f=>f.endsWith("index.html"));
    if(!indexFileName){
        win.document.body.innerHTML = "No index.html in ZIP";
        return;
    }

    const htmlBlob = new Blob([await zip.files[indexFileName].async("string")], {type:"text/html"});
    const htmlUrl = URL.createObjectURL(htmlBlob);
    iframe.src = htmlUrl;

    // Override asset requests inside iframe
    iframe.onload = () => {
        const iframeWin = iframe.contentWindow;
        const originalFetch = iframeWin.fetch;
        iframeWin.fetch = async (input, init) => {
            let path = typeof input === "string" ? input : input.url;
            let key = Object.keys(fileMap).find(k => path.endsWith(k));
            if(key){
                const b = fileMap[key];
                return new Response(b);
            }
            return originalFetch(input, init);
        };
    };
}
</script>

</body>
</html>
